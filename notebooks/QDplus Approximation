import numpy as np
from scipy.stats import norm
from scipy.optimize import root
import EuropeanPutOption as put

class QDPlus:
    def __init__(self, r, q, K, sigma, tau):
        self.r = r
        self.q = q
        self.K = K
        self.sigma = sigma
        self.tau = tau
        self.h = 1 - np.exp(-self.r * self.tau)
        self.small_omega = 2 * (self.r - self.q) / (self.sigma ** 2)
        self.temp1 = np.sqrt(((self.small_omega - 1) ** 2) + ((8 * self.r) / ((self.sigma ** 2) * self.h)))
        self.qd_lambda = (-(self.small_omega - 1) - self.temp1) / 2
        self.qd_lambda_tick = (2 * self.r) / ((self.sigma ** 2) * (self.h ** 2) * self.temp1)

    def theta(self, Beta_tau):
        d1_value = put.d1(self.r, self.q, Beta_tau, self.K, self.sigma, self.tau)
        d2_value = put.d2(self.r, self.q, Beta_tau, self.K, self.sigma, self.tau)
        term1 = self.r * self.K * np.exp(-self.r * self.tau) * norm.cdf(-d2_value)
        term2 = self.q * Beta_tau * np.exp(-self.q * self.tau) * norm.cdf(-d1_value)
        term3 = self.sigma * Beta_tau / (2 * np.sqrt(self.tau)) * np.exp(-self.q * self.tau) * norm.cdf(d1_value)
        return term1 - term2 - term3

    def c0(self, Beta_tau):
        temp2 = 2 * self.qd_lambda + self.small_omega - 1
        term_a = ((1 - self.h) * 2 * self.r / (self.sigma ** 2)) / temp2
        term_b = 1 / self.h
        term_c = np.exp(self.r * self.tau) * self.theta(Beta_tau) / (self.r * (self.K - Beta_tau - put.EuropeanOption(self.r, self.q, Beta_tau, self.K, self.sigma, self.tau)))
        term_d = self.qd_lambda_tick / temp2
        return term_a * (term_b - term_c + term_d)

    def exercise_boundary_func(self, Beta_tau):
        d1_value = put.d1(self.r, self.q, Beta_tau, self.K, self.sigma, self.tau)
        term = (self.qd_lambda + self.c0(Beta_tau)) * (self.K - Beta_tau - put.EuropeanOption(self.r, self.q, Beta_tau, self.K, self.sigma, self.tau))
        return (1 - np.exp(-self.q * self.tau) * norm.cdf(-d1_value)) + term

    def compute_exercise_boundary(self):
        res = root(self.exercise_boundary_func, x0=self.K)
        if res.success:
            return res.x[0]
        else:
            raise ValueError("Root finding did not converge: " + res.message)

# Test run
if __name__ == "__main__":    
    qd_plus = QDPlus(0.05, 0.05, 0.25, 100, 2)
    exercise_boundary = qd_plus.compute_exercise_boundary()
    print("Exercise Boundary:", exercise_boundary)
